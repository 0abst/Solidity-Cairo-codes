%lang starknet
from starkware.starknet.common.syscalls import get_caller_address
from starkware.cairo.common.math import unsigned_div_rem
from starkware.cairo.common.math_cmp import is_le
from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.cairo_builtins import HashBuiltin

# Oracle Interface Definition
const EMPIRIC_ORACLE_ADDRESS = 0x012fadd18ec1a23a160cc46981400160fbf4a7a5eed156c4669e39807265bcd4
const KEY = 28556963469423460  # str_to_felt("eth/usd")
const AGGREGATION_MODE = 120282243752302  # str_to_felt("median")

struct Tick:
    member t : felt
    member p : felt
end

@storage_var
func historical_prices(index : felt) -> (tick : Tick):
end

@storage_var
func historical_prices_len() -> (len : felt):
end
@storage_var
func historical_prices_break() -> (break : felt):
end

@contract_interface
namespace IEmpiricOracle:
    func get_value(key : felt, aggregation_mode : felt) -> (
        value : felt, decimals : felt, last_updated_timestamp : felt, num_sources_aggregated : felt
    ):
    end
end

@view
func get_historical_prices_len{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    ) -> (res : felt):
    let (len) = historical_prices_len.read()
    return (res=len)
end
# Your function
@external
func update_historical_ticks{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}(
    ) -> (answer : felt):
    alloc_locals
    let (
        eth_price, decimals, last_updated_timestamp, num_sources_aggregated
    ) = IEmpiricOracle.get_value(EMPIRIC_ORACLE_ADDRESS, KEY, AGGREGATION_MODE)
    let (i) = historical_prices_len.read()
    let (inferior) = is_le(i, 59)
    if inferior == 1:
        local new_tick : Tick
        assert new_tick.t = last_updated_timestamp
        assert new_tick.p = eth_price
        historical_prices.write(index=i, value=new_tick)

        historical_prices_len.write(value=i + 1)
    else:
        local new_tick : Tick
        assert new_tick.t = last_updated_timestamp
        assert new_tick.p = eth_price

        let (b) = historical_prices_break.read()
        let (local before_last_tick : Tick) = historical_prices.read(b + 1)
        historical_prices.write(index=0, value=before_last_tick)

        historical_prices.write(index=b + 1, value=new_tick)

        historical_prices_break.write(b + 1)
    end

    return (eth_price)
end

func get_ticks_array{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}() -> (
    ticks_array : Tick*
):
    alloc_locals
    let (ticks : Tick*) = alloc()
    let (ticks_len) = historical_prices_len.read()
    let (local first_tick : Tick) = historical_prices.read(0)
    assert ticks[0] = first_tick
    let (local break : felt) = historical_prices_break.read()
    with break:
        get_ticks_array_loop(ticks, ticks_len, 1)
    end
    return (ticks_array=ticks)
end

func get_ticks_array_loop{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, break : felt
}(ticks_array : Tick*, ticks_array_len : felt, index : felt):
    alloc_locals
    if index == ticks_array_len:
        return ()
    end
    let (_, corrected_index) = unsigned_div_rem(index + break, ticks_array_len)
    let (local current_tick : Tick) = historical_prices.read(corrected_index)

    assert ticks_array[index] = current_tick
    get_ticks_array_loop(ticks_array, ticks_array_len, index + 1)
    return ()
end

@view
func test_array_sum{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}() -> (
    sum : felt
):
    alloc_locals
    local ticks_array : Tick*
    let (ticks_array) = get_ticks_array()
    let (ticks_len) = historical_prices_len.read()

    local res : felt
    with res:
        test_array_sum_loop(ticks_array, ticks_len, 0)
    end
    return (sum=res)
end

func test_array_sum_loop{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, res : felt
}(ticks_array : Tick*, ticks_array_len : felt, index : felt):
    if index == ticks_array_len:
        return ()
    end
    let p = ticks_array[index].p
    let res = res + p
    test_array_sum_loop(ticks_array, ticks_array_len, index + 1)
    return ()
end
