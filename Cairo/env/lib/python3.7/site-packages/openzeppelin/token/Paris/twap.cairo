%lang starknet
from starkware.starknet.common.syscalls import get_caller_address
from starkware.cairo.common.math import unsigned_div_rem
from starkware.cairo.common.math_cmp import is_le
from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.cairo_builtins import HashBuiltin


from starkware.cairo.common.default_dict import default_dict_new, default_dict_finalize
from starkware.cairo.common.dict_access import DictAccess
from starkware.cairo.common.dict import dict_write, dict_read


from starkware.cairo.common.math import assert_le_felt, assert_lt_felt

# Oracle Interface Definition
const EMPIRIC_ORACLE_ADDRESS = 0x012fadd18ec1a23a160cc46981400160fbf4a7a5eed156c4669e39807265bcd4
const KEY = 28556963469423460  # str_to_felt("eth/usd")
const AGGREGATION_MODE = 120282243752302  # str_to_felt("median")

struct Tick:
    member t : felt
    member p : felt
end

@storage_var
func historical_prices(index : felt) -> (tick : Tick):
end

@storage_var
func historical_prices_len() -> (len : felt):
end
@storage_var
func historical_prices_break() -> (break : felt):
end

@contract_interface
namespace IEmpiricOracle:
    func get_value(key : felt, aggregation_mode : felt) -> (
        value : felt, decimals : felt, last_updated_timestamp : felt, num_sources_aggregated : felt
    ):
    end
end

@view
func get_historical_prices_len{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    ) -> (res : felt):
    let (len) = historical_prices_len.read()
    return (res=len)
end

# Your function
@external
func update_historical_ticks{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}(
    ) -> (answer : felt):
    alloc_locals
    let (
        eth_price, decimals, last_updated_timestamp, num_sources_aggregated
    ) = IEmpiricOracle.get_value(EMPIRIC_ORACLE_ADDRESS, KEY, AGGREGATION_MODE)
    let (i) = historical_prices_len.read()
    let (inferior) = is_le(i, 59)
    if inferior == 1:
        local new_tick : Tick
        assert new_tick.t = last_updated_timestamp
        assert new_tick.p = eth_price
        historical_prices.write(index=i, value=new_tick)

        historical_prices_len.write(value=i + 1)
    else:
        local new_tick : Tick
        assert new_tick.t = last_updated_timestamp
        assert new_tick.p = eth_price

        let (b) = historical_prices_break.read()
        let (local before_last_tick : Tick) = historical_prices.read(b + 1)
        historical_prices.write(index=0, value=before_last_tick)

        historical_prices.write(index=b + 1, value=new_tick)

        historical_prices_break.write(b + 1)
    end

    return (eth_price)
end

func get_ticks_array{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}() -> (
    ticks_array : Tick*
):
    alloc_locals
    let (ticks : Tick*) = alloc()
    let (ticks_len) = historical_prices_len.read()
    let (local first_tick : Tick) = historical_prices.read(0)
    assert ticks[0] = first_tick
    let (local break : felt) = historical_prices_break.read()
    with break:
        get_ticks_array_loop(ticks, ticks_len, 1)
    end
    return (ticks_array=ticks)
end

func get_ticks_array_loop{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, break : felt
}(ticks_array : Tick*, ticks_array_len : felt, index : felt):
    alloc_locals
    if index == ticks_array_len:
        return ()
    end
    let (_, corrected_index) = unsigned_div_rem(index + break, ticks_array_len)
    let (local current_tick : Tick) = historical_prices.read(corrected_index)

    assert ticks_array[index] = current_tick
    get_ticks_array_loop(ticks_array, ticks_array_len, index + 1)
    return ()
end

@view
func array_sum{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}() -> (
    sum : felt
):
    alloc_locals
    local ticks_array : Tick*
    let (ticks_array) = get_ticks_array()
    let (ticks_len) = historical_prices_len.read()

    let res =0
    with res:
        array_sum_loop(ticks_array, ticks_len, 0)
    end
    return (sum=res)
end

func array_sum_loop{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, res : felt
}(ticks_array : Tick*, ticks_array_len : felt, index : felt):
    if index == ticks_array_len:
        return ()
    end
    let p = ticks_array[index].p
    let res = res + p
    array_sum_loop(ticks_array, ticks_array_len, index + 1)
    return ()
end


@view
func bullish_trend{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, res : felt}
(ticks_array : Tick*, historical_prices_len : felt)-> (
    res : felt
):
    let (end) = ticks_array[historical_prices_len-1].p
    let (end1) = ticks_array[historical_prices_len-2].p
    result1=is_le(end,end1)
    if result1 == 1:
        return(res="bullish")
    end
end


@view
func bearish_trend{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, res : felt}
(ticks_array : Tick*, historical_prices_len : felt)-> (res : felt):
    let (end) = ticks_array[historical_prices_len-1].p
    let (end1) = ticks_array[historical_prices_len-2].p
    result1=is_le(end1,end)
    if result1 == 1:
        return(res="bearish")
    end
end

#@view
#func volatility{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, res : felt}





#function sum
func array_sum(arr : felt*, size) -> (sum : felt):
    let (sum_of_rest) = array_sum(arr=arr + 1, size=size - 1)
    return (sum=[arr] + sum_of_rest)
end


#function mean
@view
func compute_mean{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}(ticks_array : Tick*, ticks_array_len : felt)-> (sum: felt, mean : felt):
    let (ticks_array_len) = historical_prices_len.read()
    let (sum)=array_sum(ticks_array, ticks_array_len)
    let mean = sum / ticks_array_len
    return(mean)
end




func get_ticks_array{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}() -> (
    ticks_array : Tick*
):
    alloc_locals
    let (ticks : Tick*) = alloc()
    let (ticks_len) = historical_prices_len.read()
    let (local first_tick : Tick) = historical_prices.read(0)
    assert ticks[0] = first_tick
    let (local break : felt) = historical_prices_break.read()
    
    

    with break:
        get_ticks_array_loop(ticks, ticks_len, 1)

    end
    
    return (ticks_array=ticks)

end

func get_ticks_array_loop{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*, break : felt
}(ticks_array : Tick*, ticks_array_len : felt, index : felt):

    alloc_locals

    if index == ticks_array_len:
        return ()
    end

    let (local current_tick : Tick) = historical_prices.read(corrected_index)

    assert ticks_array[index] = current_tick
    get_ticks_array_loop(ticks_array, ticks_array_len, index + 1)
    return ()
end

































# Computes the sum of the memory elements at addresses:
#   arr + 0, arr + 1, ..., arr + (size - 1).
func array_sum(arr : felt*, size) -> (sum : felt):
    if size == 0:
        return (sum=0)
    end
    # size is not zero.
    let (sum_of_rest) = array_sum(arr=arr + 1, size=size - 1)
    return (sum=[arr] + sum_of_rest)
end



##Seconde phase
#%lang starknet
#from starkware.cairo.common.alloc import alloc
#from starkware.cairo.common.default_dict import default_dict_new, default_dict_finalize
#from starkware.cairo.common.dict_access import DictAccess
#from starkware.cairo.common.dict import dict_write, dict_read

@external
func test_array{syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr}():

    alloc_locals
    let (ticks : felt*) = alloc()

    let (local my_dict_start) = default_dict_new(default_value=0)
    let my_dict = my_dict_start
    # let (finalized_dict_start, finalized_dict_end) = default_dict_finalize(
    #    my_dict_start, my_dict, 0
    # )
    dict_write{dict_ptr=my_dict}(key=0, new_value=1000)
    dict_write{dict_ptr=my_dict}(key=1, new_value=1100)
    dict_write{dict_ptr=my_dict}(key=2, new_value=1200)
    dict_write{dict_ptr=my_dict}(key=3, new_value=1300)
    dict_write{dict_ptr=my_dict}(key=4, new_value=1400)
    %{ print(__dict_manager.get_dict(ids.my_dict)) %}

    assert 1 = 1
    return ()
end
